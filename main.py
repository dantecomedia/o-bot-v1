import streamlit as st
import requests
import json
from bs4 import BeautifulSoup
import concurrent.futures
import re
import os
import time

# Set OpenAI and Serp API keys from environment variables
openai_api_key = os.environ.get('oai')
serp_api = os.environ.get('serp')

# Headers for OpenAI API
headers = {
    'Authorization': 'Bearer ' + openai_api_key,
    'Content-Type': 'application/json',
}

# Function to parse and clean JSON
def to_json(string):
    string = string.strip().replace('<json>', '').replace('</json>', '')
    start_index = string.find('{')
    end_index = string.rfind('}')
    json_string = string[start_index:end_index + 1]
    data = json.loads(json_string, strict=False)
    return data

# Function to simulate streaming the summarizer response
def summarizer_stream(context, query, outcome):
    outcome_str = json.dumps(outcome, indent=4)
    prompt = f"""
    Query :{query}
    Context :{context}
    Search API Yield :{outcome_str}

    Query is the query provided by the user, Context has the previous response from the previous question and follow-up question,
    Search API Yield is the outcome of the query from the search API

    Your job is to generate a clean concise summary, highlight all information, provide as many outcomes, and also use your knowledge to correct the information,
    Generate the outcome in the most readable way, either in points or in listicle format as necessary.

    Format the output as JSON with the following keys:
    res // main key
    outcome // Nested key, it has the overall summary and highlights generated by you, make sure it is well structured and also make sure that you add more additional information to the topic based on your knowledge, its value should be string, avoid using extra spaces and new lines
    follow_up // Nested key, It has the list of follow-up question suggestions based on context.
    prequisiter // Nested key, It has the list of summaries for information from your knowledge which might be required while understanding the topic

    Do not output anything except for the information. Do not add any clarifying information. Do not add any fields that are not in the schema. If the text contains attributes that do not appear in the schema, please ignore them. All output must be in JSON format and follow the schema specified above. Wrap the JSON in <json> tags.
    
    An example json output :
<json>
{{
    "res": {{
        "outcome": "Quantum computing is a rapidly advancing field that leverages the principles of quantum mechanics to perform computations that are infeasible for classical computers. Here are some key aspects and additional information about quantum computing:\n1. Basics of Quantum Computing:\n   - Qubits: Quantum bits or qubits are the fundamental units of quantum information, capable of representing both 0 and 1 simultaneously due to superposition.\n   - Superposition: This principle allows qubits to be in multiple states at once, enabling parallel computation.\n   - Entanglement: A phenomenon where qubits become interconnected and the state of one qubit instantly influences the state of another, regardless of distance.\n   - Quantum Gates: Operations that manipulate qubits, similar to logic gates in classical computing, but can perform more complex transformations.\n2. Advantages of Quantum Computing:\n   - Speed: Quantum computers can solve certain problems much faster than classical computers, particularly in optimization, cryptography, and complex simulations.\n   - Parallelism: Due to superposition, quantum computers can evaluate multiple possibilities simultaneously, drastically reducing computation time for specific tasks.\n3. Quantum Algorithms:\n   - Shor's Algorithm: Efficiently factors large numbers, threatening current cryptographic systems.\n   - Grover's Algorithm: Provides a quadratic speedup for unsorted database searches.\n   - Quantum Simulation: Simulates quantum systems that are intractable for classical computers, with applications in chemistry and materials science.\n4. Current Challenges:\n   - Decoherence: The loss of quantum state coherence due to environmental interactions, which can lead to errors in computation.\n   - Error Correction: Developing error-correcting codes to protect quantum information and maintain computational accuracy.\n   - Scalability: Building scalable quantum systems with a large number of qubits while maintaining coherence and low error rates.\n5. Real-World Applications:\n   - Cryptography: Quantum computing poses both threats and opportunities for encryption, leading to the development of quantum-resistant algorithms.\n   - Drug Discovery: Quantum simulations can model molecular interactions at a quantum level, accelerating drug development.\n   - Optimization: Applications in logistics, finance, and supply chain management to find optimal solutions more efficiently.\n6. Future Prospects:\n   - Quantum Supremacy: Achieving computational tasks beyond the reach of classical computers.\n   - Hybrid Systems: Integrating quantum processors with classical supercomputers to enhance performance for specific tasks.\n   - Quantum Internet: Developing secure communication networks based on quantum encryption techniques.",
        "follow_up": [
            "What are the differences between classical and quantum computing?",
            "How does quantum entanglement work in practical applications?",
            "What industries will benefit the most from quantum computing?",
            "What are the latest advancements in quantum error correction?"
        ],
        "prequisiter": [
            "Superposition is a fundamental principle of quantum mechanics where particles exist in multiple states at once until measured.",
            "Entanglement is a quantum phenomenon where particles become linked and the state of one affects the state of another instantly.",
            "Quantum gates are the building blocks of quantum circuits, manipulating qubits to perform computations."
        ]
    }}
}}
</json>

    """
    json_data = {
        'model': 'gpt-4o',
        'temperature': 0.7,
        'messages': [{'role': 'user', 'content': prompt}],
    }
    response = requests.post('https://api.openai.com/v1/chat/completions', headers=headers, json=json_data, stream=True)
    if response.status_code != 200:
        st.session_state.status = 'red'
        yield None
    collected_chunks = []
    for chunk in response.iter_content(chunk_size=512):
        if chunk:
            collected_chunks.append(chunk.decode('utf-8'))
            partial_response = ''.join(collected_chunks)
            try:
                parsed_json = json.loads(partial_response)
                z = parsed_json['choices'][0]['message']['content']
                out = to_json(z)
                st.session_state.status = 'green'
                yield out
            except Exception as e:
                pass

# Function to update the context with filtered text
def update_context(context, query, summary, max_context_length=5000):
    q_num = len(context) // 2 + 1
    context[f'q_{q_num}'] = query
    context[f'ans_{q_num}'] = summary['res']['outcome']
    context_str = json.dumps(context)
    if len(context_str) > max_context_length:
        summarized_context = summarize_context(context)
        context = summarized_context
    return context

# Function to summarize the context using a sliding window approach
def summarize_context(context, window_size=3):
    summarized_context = {}
    context_items = list(context.items())
    num_items = len(context_items) // 2
    for i in range(1, num_items + 1):
        start = max(0, (i - window_size) * 2)
        end = min(len(context_items), (i + 1) * 2)
        for j in range(start, end):
            key, value = context_items[j]
            summarized_context[key] = value
    return summarized_context

# Function to fetch and filter relevant text from a URL
def fetch_and_filter_text(url, query, max_length=1000):
    try:
        response = requests.get(url, timeout=10)
        response.raise_for_status()
        soup = BeautifulSoup(response.content, 'html.parser')
        text_parts = [element.get_text(strip=True) for tag in ['p', 'div', 'span', 'article'] for element in soup.find_all(tag)]
        text = ' '.join(text_parts)
        query_terms = re.findall(r'\b\w+\b', query)
        relevant_sentences = [sentence for sentence in text.split('. ') if any(term.lower() in sentence.lower() for term in query_terms)]
        filtered_text = '. '.join(relevant_sentences)
        if len(filtered_text) > max_length:
            filtered_text = filtered_text[:max_length] + '...'
        return {'url': url, 'text': filtered_text}
    except requests.RequestException as e:
        return {'url': url, 'text': f"Request error: {e}"}
    except Exception as e:
        return {'url': url, 'text': f"General error: {e}"}

# Function to fetch search results from Google Search API
def fetch_search_results(query):
    url = "https://google-api31.p.rapidapi.com/websearch"
    payload = {"text": query, "safesearch": "off", "timelimit": "", "region": "wt-wt", "max_results": 20}
    headers = {"x-rapidapi-key": serp_api, "x-rapidapi-host": "google-api31.p.rapidapi.com", "Content-Type": "application/json"}
    response = requests.post(url, json=payload, headers=headers)
    if response.status_code != 200:
        print(f"Error fetching search results: {response.status_code}")
        return []
    try:
        data = response.json()
        print("Search API response:", json.dumps(data, indent=4))
        return data.get('result', [])
    except Exception as e:
        print(f"Error parsing search results: {e}")
        return []

def main():
    st.title("O BOT")
    if 'context' not in st.session_state:
        st.session_state.context = {}
    if 'authenticated' not in st.session_state:
        st.session_state.authenticated = False
    if 'chat_history' not in st.session_state:
        st.session_state.chat_history = []
    if 'status' not in st.session_state:
        st.session_state.status = 'green'
    if 'query' not in st.session_state:
        st.session_state.query = ""

    context = st.session_state.context
    if not st.session_state.authenticated:
        username = st.text_input("Username")
        password = st.text_input("Password", type="password")
        if st.button("Login"):
            if username == "admin" and password == "password":
                st.session_state.authenticated = True
                st.success("Logged in successfully")
                st.experimental_rerun()
            else:
                st.error("Invalid username or password")
    if st.session_state.authenticated:
        for chat in st.session_state.chat_history:
            st.markdown(f"<div style='text-align: right; border: 1px dotted #000; padding: 10px; margin: 5px; border-radius: 10px;'>{chat['query']}</div>", unsafe_allow_html=True)
            st.markdown(f"<div style='text-align: left; border: 1px dotted #000; padding: 10px; margin: 5px; border-radius: 10px; white-space: pre-wrap;'>{chat['response']}</div>", unsafe_allow_html=True)
            if chat['follow_up']:
                with st.expander("Follow Up Questions", expanded=True):
                    for q in chat['follow_up']:
                        st.markdown(f"- {q}")
            if chat['prequisiter']:
                with st.expander("Prerequisite Information", expanded=True):
                    for info in chat['prequisiter']:
                        st.markdown(f"- {info}")
        status = st.session_state.status
        if status == 'green':
            st.markdown('<div style="background-color:green;color:white;padding:10px;">API Status: Success</div>', unsafe_allow_html=True)
        elif status == 'yellow':
            st.markdown('<div style="background-color:yellow;color:black;padding:10px;">API Status: Processing</div>', unsafe_allow_html=True)
        elif status == 'red':
            st.markdown('<div style="background-color:red;color:white;padding:10px;">API Status: Error</div>', unsafe_allow_html=True)
        query = st.text_input("Enter your query", value="", key="query_input")
        submit_button = st.button("Search")
        if submit_button and query:
            st.session_state.query = query
            st.session_state.status = 'yellow'
            st.experimental_rerun()
        if st.session_state.status == 'yellow' and st.session_state.query:
            search_results = fetch_search_results(st.session_state.query)
            urls = [result.get('href') for result in search_results]
            results_list = []
            with concurrent.futures.ThreadPoolExecutor() as executor:
                future_to_url = {executor.submit(fetch_and_filter_text, url, st.session_state.query): url for url in urls}
                for future in concurrent.futures.as_completed(future_to_url):
                    try:
                        result = future.result()
                        results_list.append(result)
                    except Exception as exc:
                        st.session_state.status = 'red'
                        st.error(f"Error fetching text: {exc}")
                        st.experimental_rerun()
            response_placeholder = st.empty()
            response_text = ""
            for summary in summarizer_stream(context, st.session_state.query, results_list):
                if summary:
                    context = update_context(context, st.session_state.query, summary)
                    st.session_state.context = context
                    st.session_state.chat_history.append({
                        "query": st.session_state.query,
                        "response": summary['res']['outcome'],
                        "follow_up": summary['res'].get('follow_up', []),
                        "prequisiter": summary['res'].get('prequisiter', [])
                    })
                    st.session_state.status = 'green'
                    st.session_state.query = ""
                    response_text = ""
                    for char in summary['res']['outcome']:
                        response_text += char
                        response_placeholder.markdown(f"<div style='text-align: left; border: 1px dotted #000; padding: 10px; margin: 5px; border-radius: 10px; white-space: pre-wrap;'>{response_text}</div>", unsafe_allow_html=True)
                        time.sleep(0.001)
                else:
                    st.session_state.status = 'red'
            st.experimental_rerun()

if __name__ == "__main__":
    main()
